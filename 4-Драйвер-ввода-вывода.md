# Пример драйвера ввода/вывода реализация на МЭК

## Ссылки

докуменнтация:
https://forge.codesys.com/drv/io-drivers/doc/Generic/

Пример:
https://disk.yandex.ru/d/iGOa2OkNmfuDVA


## Принцип работы

Задача драйвера ввода/вывода (далее драйвера I/O) состоит в передачи данных из железа в переменные МЭК проекта и обратно из переменных МЭК проекта на железо.
Согласно стандарту МЭК 61131-3 (далее просто стандарт) рабочий цикл ПЛК (далее МЭК цикл) включает 3 основные секции: 

1.	Чтение входов
2.	Обработка считанных данных и формирование сигнала управления
3.	Запись выходов

Драйвер I/O обеспечивает работу 1ой и 3тей секции. Под второй секцией в данном случае подразумевается МЭК программа. 
То есть прикладная программа управление объектом написанная на МЭК языках. МЭК программа и драйвер работают под управлением
рантайма кодесис. Вся программная система (рантайм, драйвер и МЭК программа) работают в ОС Линукс в пространстве
пользователя (см интернет по словам: userspace linux) и доступ к железу могут осуществлять только через предоставляемый АПИ 
Линукса, предоставляемый ядром линукса процессам userspace. Драйвер осуществляет чтение входов ПЛК и запись данных на выходы 
ПЛК только через функции ОС. На первой стадии МЭК цикла чтения входов драйвер считывает c железа данные средствами АПИ Линукса
и передает их в МЭК программу. Согласно стандарту, считываемые данные принято обозначать %I. Следующей секцией МЭК цикла
исполняется МЭК программа, которая готовит сигналы управления согласно заданной логики, записывая данные в переменные, которые
будут выведены на выходы ПЛК. Данные, подготавливаемые для записи на выходы ПЛК, обозначают %Q. 
 
ВАЖНО: 

    Данные %I не меняются после окончания 1 стадии МЭК цикла и сохраняют свое значения на протяжении всей 2 стадии МЭК цикла. 
    Данные %Q могут меняться программной до окончания 2ой стадии, и они не попадают на выходы ПЛК до окончания 2 стадии.
    
На стадии 3 МЭК цикла драйвер получает данные от МЭК программы для записи на выходы ПЛК и так же функционалом АПИ Линукса осуществляет
запись данных в железо.

Принцип работы драйвера не зависит от построения системы I/O. Система I/O может быть GPIO, полевой шиной, файлами или смешанными, 
для драйвера это просто источники, которые читаются разными способами и данные из которых передаются в МЭК проект строго определенным способом.
Задача системного программиста, разрабатывающего драйвер I/O, в простейшем случае сводится к написанию кода считывания и записи данных 
как требует система I/O его ПЛК, и расположения данных в областях, где того требует МЭК программа.

## Структура драйвера

Драйвер I/O представляет собой класс объекта I/O. Драйвер реализует множество методов, из которых системному программисту 
потребуется реализовывать 3 – 4 метода. В предоставляемом примере IoDrvTemplate (файл IoDrvTemplate.library) показана реализация 
всех методов. Рекомендуется брать этот пример за основу для реализации собственного драйвера.

## Состав и принцип работы примера

Пример состоит из файлов:
1. MyDeviceIECDriver.devdesc.xml – Описание структуры I/O
1. IoDrvTemplate.library - Драйвер I/O
1. IoDrvTemplateIecDriverTest.project – МЭК проект демонстрирующий работу драйвера.

Пример драйвера максимально прост. В драйвере определены два массива данных. Один массив используется как источник данных 
и имитирует входы ПЛК. Второй массив имитирует выходы ПЛК. МЭК программа считывает входы %I и формирует данные %Q для выходов. 
Драйвер получает от МЭК программы %Q данные и записывает их в массив данных для выходов имитируя запись в железо. Для имитации
сигналов со входов ПЛК драйвер просто копирует данные с массива данных выходов на массив данных входа. Таким образом драйвер имитирует
зашунтированные входы ПЛК на выходы ПЛК, а МЭК программа получает на вход те значения, которые посылала на выход. 
Для применения драйвера на реальном железе минимально необходимо убрать из драйвера строчку копирования массивов, и написать код обмена
данных массивов с железом. Места кода драйвера где следует это сделать будут описаны ниже.

## Файл описания устройств

Структура система I/O на ПЛК в программных проектах МЭК Кодесис описывается в  *.devdesc.xml файлах. Эти файлы называются файлами
описания устройств (devdesc сокращенно device description). В этих файлах структурно описываются все входы, выходы и прочие параметры,
предоставляемые в прикладной МЭК проект. Структуры файлов описания устройств считываются драйвером. Таким образом МЭК проект и
драйвер I/O получают одинаковые структуры, описывающие I/O. С одной стороны МЭК проект использует эти структуры для получения данных
со входов и записи данных на выходы. С другой стороны, драйвер I/O заполняет эти структуры данными со входов ПЛК и записывает из этих
структур данные на выходы ПЛК.

Структуры файлов I/O описываются в докуменнтации. Тут мы рассмотрим основные моменты на примере файла описания устройств MyDeviceIECDriver.devdesc.xml.
Данные описываются структурами так, как считается удобным разработчиком ПЛК для предоставления прикладному МЭК программисту.
Элементом данных является структура, называемая параметром (Parameter). Каждый параметр системы I/O должен обладать уникальным
значением ParameterId по которому его найдет драйвер I/O. 

Принято всем параметрам данных %I (входы)  давать значения ParameterId от 1000, данным %Q от 2000.
В примере файла описания устройств показан параметр ParameterId="1000":

```
<Parameter ParameterId="1000" type="std:DWORD">
	<Attributes channel="input"/>
	…
	<Name name="local:in1">in1</Name>
</Parameter>
```

Этот параметр с названием in1 описывает данные %I предоставляемые одним битовым полем стандартного типа DWORD.
Следующий параметр ParameterId="1001" также описывает некоторый набор битовых полей, представленных определенным в этом же файле
типом TBYTE, который в свою очередь позволяет описывать каждый бит отдельно.

Параметры ParameterId="2000" и ParameterId="2001" имеют предоставляют аналогичные структуры для данных %Q (выходы).
В прикладном проекте файл описания MyDeviceIECDriver.devdesc.xml устройств предоставит 2 группы битовых полей как входы и 2 группы
битовых полей как выходы. Первые группы организованы в 4батовую переменную, вторые группы в однобайтовую. Таким образом в МЭК проекте
предоставляется возможность привязывать переменные к входам и выходам как побитно, так и целиком к группам бит одновременно.

## Пример МЭК проекта

Для использования примера МЭК проекта следует добавить файл устройств MyDeviceIECDriver.devdesc.xml в IDE CODESYS в
меню `Инструменты -> Репозиторий устройств` и билиотеку IoDrvTemplate.library  в `Инструменты -> Репозиторий библиотек`.
В дереве устройств МЭК проекта добавлен узел с названием MyCard_IecDriver. Этот узел представляет собой объект I/O
описанный в MyDeviceIECDriver.devdesc.xml и подключенных к прикладному проекту для использования. Переход к I/O программы производится
двойным кликом на узле MyCard_IecDriver в дереве устройств. По вдойному клику открывается окно с рядом вкладок. Предоставляемые I/O
для проекта находятся во вкладке Intrnal Соотнесения входов/выходов. В проекте для примера используются всего две переменные dwIn1
для входов и dwOut1 для выходов определенные в программе Main. Переменная dwIn1 соотнесена на вход in1 (тот, что выше описан с ParameterId="1000"),
а переменная dwOut1 соотнесена с выходом out1.

Сам код программы main прост несмотря на множество строк. Для приведенного примера важна только одна строка:
```dwOut1 := dwIn1 + 1;```
В этой строке вся логика программы. Остальной текст программы приведен для более сложных тестов, которые можно изучить по документации.
Для базового понимания всю логику кроме вышеприведённой строчки можно игнорировать.

Логика примера: Каждый цикл ПЛК считывать вход и записывать на выход значение на единицу больше считанного входа.

## Драйвер I/O

Для узла MyCard_IecDriver в МЭК проекте драйвер I/O создает экземпляр класса IoDrvTemplate из библиотеки IoDrvTemplate.library. Созданный объект
полностью обслуживает всю логику работы I/O для конкретного узла MyCard_IecDriver в МЭК проекте.  Реализация драйвера для примера затрагивает 4 метода. 
Самый объемный по коду требуемого от системного программиста реализующего драйвер это метод IoDrvUpdateConfiguration. Этот метод вызывается после
создания экземпляра класса и предназначен для считывания структуры файла описания устройств, нахождения в ней входов и выходов, которые будут
обслуживаться в процессе МЭК цикла.

В первой стадии МЭК цикла (чтение входов) вызывается метод IoDrvReadInputs. Этот метод предназначен для предоставления данных со входов на в
область %I в МЭК проект. В третьей стадии МЭК цикла вызывается метод IoDrvWriteOutputs, который должен перенести %Q память МЭК проекта на выходы ПЛК.

В приведенном примере вместо входов и выходов используются массивы _byInputs и _byOutputs определенные в классе драйвера.

Метод IoDrvUpdateConfiguration получает на вход указатель на структуру данных IoConfigConnector и значение указывающее количество элементов в ней nCount.
Структура данных формируется на основе файлов описания устройств и имеет сложную вложенность, которую можно изучать с помощью документации и методом
точек останова, но для большинства задач этого не потребуется. Вся реализация разбора структуры уже реализована в методе IoDrvUpdateConfiguration для
примера, в котором следует обратить внимание на строчки:

```
pParameter := IoMgrConfigGetParameter(m_pConnector, 1000);		(* inputs *)
IF (pParameter <> 0) THEN
pParameter^.dwDriverSpecific := ADR(_byInputs[0]);			(* Device offset 0 *)
END_IF
```

Эти строчки находят в структуре данных параметр с ID равным 1000 и записывают в его поле dwDriverSpecific указатель на первую ячейку массива входов. 
Глобальная структура данных по указателю IoConfigConnector будет передаваться как частями, так и целиком в процессе работы всего программного
комплекса в разные методы. Где бы не появилось обращение к параметру с ID=1000 можно всегда получить адрес в его поле dwDriverSpecific к которому
он был «привязан» строчками выше в методе IoDrvUpdateConfiguration. В данном примере это адрес ячейки _byInputs[0].
Если например в ячейку _byInputs[0] считывать состояние GPIO_10 (где это сделать ниже будет указанно), то по указателю в поле dwDriverSpecific 
параметра с ID = 1000 можно будет считать данные GPIO_10. 

**Напоминание: параметр с id=1000 определен в файле MyDeviceIECDriver.devdesc.xml как вход:** `<Parameter ParameterId="1000" type="std:DWORD">`

Таким образом производится привязка каждого параметра в ячейках массивов входов и выходов. Ниже в методе IoDrvUpdateConfiguration происходит
привязка по всем параметрам I/O определенных в MyDeviceIECDriver.devdesc.xml.

## Чтение входов

Чтение входов ПЛК осуществляется в методе IoDrvReadInputs. Метод получает на вход указатель pConnectorMapList на некоторую структуру входов и их
количество nCount, сформированных где-то в недрах рантайма после вызова IoDrvUpdateConfiguration. Структура по указателю pConnectorMapList представляет
собой список параметров описывающие входы, каждому элементу которого в поле dwDriverSpecific был записан указатель на ячейки массива _ byInputs. 
Суть метода сводится к перебору всех параметров списка и вызова для каждого функции:
IoMgrCopyInputLE(pChannelMap, pChannelMap^.pParameter^.dwDriverSpecific);
Эта функция копирует данные, взятые по указателю сохраненному в dwDriverSpecific параметра в область %I связанную с МЭК проектом.  Таким образом данные
ячеек массива _byInputs попадают в МЭК проект как входы %I.  Следует обратить внимание на последние две буквы в названии функции IoMgrCopyInputLE – LE.
Они говорят о том, что эта функция копирует данные с порядком байт Little Endian. Для порядка байт Big Endian существует функция IoMgrCopyInputВE.

## Запись выходов

Запись выходов осуществляется в методе IoDrvWriteOutputs.  Тут все аналогично методу чтения входов за исключением направления копирования данных.
Функция IoMgrCopyOutputLE копирует данные МЭК проекта из области %Q привязанной к параметру выхода в область по указателю, сохраненному в параметре в
поле dwDriverSpecific - указатель на ячейку _byOutputs в примере. 
```
IoMgrCopyOutputLE(pChannelMap, pChannelMap^.pParameter^.dwDriverSpecific);	
```

## Шунтирование выходов на входы для примера

Вышеописанное шунтирование имитируемых входов на выходы производится в методе IoDrvStartBusCycle копировавнием одного массива на другой:
```
MemCpy(ADR(_byInputs), ADR(_byOutputs), IOSize);
```
Метод IoDrvStartBusCycle вызывается независимо от МЭК цикла ПЛК и прямо не влияет на него. Этот метод вызывается и обычно используется для различной
диагностики основного цикла ПЛК. 

## Привязка примера к GPIO

Для привязки примера к реальным GPIO следует:

1. Удалить имитацию шунта из IoDrvStartBusCycle: `MemCpy(ADR(_byInputs), ADR(_byOutputs), IOSize)`
1. Добавить инициализацию GPIO в IoDrvUpdateConfiguration
1. Считать данные из GPIO в _byInputs в начале IoDrvReadInputs
1. Записать данные из _byOutputs в GPIO в конце IoDrvWriteOutputs


